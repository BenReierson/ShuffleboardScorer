<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puck Detection Tests</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background: #0b0f14;
      color: #e7eef7;
    }
    h1, h2 { color: #4aa3ff; }
    .test { 
      margin: 20px 0; 
      padding: 15px; 
      background: #121a22; 
      border-radius: 8px;
      border-left: 4px solid #223140;
    }
    .test.pass { border-left-color: #36d399; }
    .test.fail { border-left-color: #fb7185; }
    .test h3 { margin-top: 0; }
    .result { 
      padding: 10px; 
      margin: 10px 0; 
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
    }
    .pass { background: #1f6b4f; color: #baf7dd; }
    .fail { background: #7a2430; color: #ffd2d8; }
    canvas { 
      border: 1px solid #223140; 
      margin: 10px 0;
      image-rendering: pixelated;
    }
    .summary {
      padding: 20px;
      margin: 20px 0;
      background: #1f2b38;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
    }
    .code {
      background: #0f1620;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      overflow-x: auto;
    }
    pre {
      margin: 0;
      color: #9fb0c2;
    }
  </style>
</head>
<body>
  <h1>üéØ Shuffleboard Puck Detection Unit Tests</h1>
  <div id="results"></div>
  <div id="summary" class="summary"></div>

  <script>
    // Test utilities
    const results = [];
    const resultsEl = document.getElementById('results');
    const summaryEl = document.getElementById('summary');

    function assert(condition, message) {
      if (!condition) {
        throw new Error(`Assertion failed: ${message}`);
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(`${message}: expected ${expected}, got ${actual}`);
      }
    }

    function assertApprox(actual, expected, tolerance, message) {
      if (Math.abs(actual - expected) > tolerance) {
        throw new Error(`${message}: expected ${expected}¬±${tolerance}, got ${actual}`);
      }
    }

    function test(name, fn) {
      const testEl = document.createElement('div');
      testEl.className = 'test';
      testEl.innerHTML = `<h3>‚è≥ ${name}</h3>`;
      resultsEl.appendChild(testEl);

      try {
        const result = fn();
        testEl.className = 'test pass';
        testEl.innerHTML = `<h3>‚úÖ ${name}</h3>` + 
          (result ? `<div class="result pass">${result}</div>` : '');
        results.push({ name, pass: true });
      } catch (err) {
        testEl.className = 'test fail';
        testEl.innerHTML = `<h3>‚ùå ${name}</h3><div class="result fail">${err.message}</div>`;
        results.push({ name, pass: false, error: err.message });
      }
    }

    // Core detection functions (extracted from app.js)
    function rgbToGray(r, g, b) {
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    function createTestImage(width, height, fill) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      
      if (typeof fill === 'function') {
        const imageData = ctx.createImageData(width, height);
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const rgb = fill(x, y);
            imageData.data[i] = rgb.r;
            imageData.data[i + 1] = rgb.g;
            imageData.data[i + 2] = rgb.b;
            imageData.data[i + 3] = 255;
          }
        }
        ctx.putImageData(imageData, 0, 0);
      } else {
        ctx.fillStyle = fill;
        ctx.fillRect(0, 0, width, height);
      }
      
      return canvas;
    }

    function detectBlackPixels(imageData, threshold) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const mask = new Uint8Array(width * height);
      
      for (let i = 0; i < data.length; i += 4) {
        const gray = rgbToGray(data[i], data[i+1], data[i+2]);
        if (gray <= threshold) {
          mask[i / 4] = 1;
        }
      }
      
      return mask;
    }

    function detectWhitePixels(imageData, threshold) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const mask = new Uint8Array(width * height);
      
      for (let i = 0; i < data.length; i += 4) {
        const gray = rgbToGray(data[i], data[i+1], data[i+2]);
        if (gray >= threshold) {
          mask[i / 4] = 1;
        }
      }
      
      return mask;
    }

    function countMaskPixels(mask) {
      return mask.reduce((sum, val) => sum + val, 0);
    }

    // TESTS

    test('Grayscale conversion: pure black', () => {
      const gray = rgbToGray(0, 0, 0);
      assertEqual(gray, 0, 'Black should be 0');
      return `Gray value: ${gray}`;
    });

    test('Grayscale conversion: pure white', () => {
      const gray = rgbToGray(255, 255, 255);
      assertEqual(gray, 255, 'White should be 255');
      return `Gray value: ${gray}`;
    });

    test('Grayscale conversion: medium gray', () => {
      const gray = rgbToGray(128, 128, 128);
      assertApprox(gray, 128, 1, 'Gray should be ~128');
      return `Gray value: ${gray.toFixed(1)}`;
    });

    test('Grayscale conversion: dark blue', () => {
      const gray = rgbToGray(0, 0, 50);
      assert(gray < 20, 'Dark blue should have low gray value');
      return `Gray value: ${gray.toFixed(1)} (should be dark)`;
    });

    test('Grayscale conversion: dark red', () => {
      const gray = rgbToGray(50, 0, 0);
      assert(gray < 30, 'Dark red should have low gray value');
      return `Gray value: ${gray.toFixed(1)} (should be dark)`;
    });

    test('Threshold detection: black sticker on wood background', () => {
      // Simulate: black sticker (gray=50) on wood background (gray=140)
      const canvas = createTestImage(100, 100, (x, y) => {
        // Center circle is black sticker
        const dx = x - 50, dy = y - 50;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 15) {
          return { r: 50, g: 50, b: 50 }; // Black sticker
        }
        return { r: 140, g: 120, b: 100 }; // Wood background
      });
      
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, 100, 100);
      
      // Test with threshold of 95 (new default)
      const mask = detectBlackPixels(imageData, 95);
      const blackCount = countMaskPixels(mask);
      
      // Should detect the center circle (approximately œÄ*15¬≤ ‚âà 707 pixels)
      const expectedArea = Math.PI * 15 * 15;
      assertApprox(blackCount, expectedArea, 100, 'Should detect center black circle');
      
      resultsEl.appendChild(canvas);
      return `Detected ${blackCount} black pixels (expected ~${Math.round(expectedArea)})`;
    });

    test('Threshold detection: white sticker on wood background', () => {
      const canvas = createTestImage(100, 100, (x, y) => {
        const dx = x - 50, dy = y - 50;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 15) {
          return { r: 200, g: 200, b: 200 }; // White sticker
        }
        return { r: 140, g: 120, b: 100 }; // Wood background
      });
      
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, 100, 100);
      
      // Test with threshold of 165 (new default)
      const mask = detectWhitePixels(imageData, 165);
      const whiteCount = countMaskPixels(mask);
      
      const expectedArea = Math.PI * 15 * 15;
      assertApprox(whiteCount, expectedArea, 100, 'Should detect center white circle');
      
      resultsEl.appendChild(canvas);
      return `Detected ${whiteCount} white pixels (expected ~${Math.round(expectedArea)})`;
    });

    test('Threshold sensitivity: old vs new defaults', () => {
      // Test with a sticker at gray=75 (typical dark sticker in good lighting)
      const grayValue = 75;
      
      const oldBlackThresh = 60;
      const newBlackThresh = 95;
      
      const detectedOld = grayValue <= oldBlackThresh;
      const detectedNew = grayValue <= newBlackThresh;
      
      assert(!detectedOld, 'Old threshold (60) should NOT detect sticker at gray=75');
      assert(detectedNew, 'New threshold (95) SHOULD detect sticker at gray=75');
      
      return `Sticker at gray=${grayValue}: OLD (‚â§60)=${detectedOld} ‚ùå, NEW (‚â§95)=${detectedNew} ‚úÖ`;
    });

    test('Sampling logic: black sticker range', () => {
      // Simulate sampling a black sticker at gray=70
      const sampledGray = 70;
      
      // Old logic: gray + 20 = 90
      const oldThresh = Math.min(140, Math.max(5, Math.round(sampledGray + 20)));
      
      // New logic: gray * 1.4 = 98
      const newThresh = Math.min(150, Math.max(20, Math.round(sampledGray * 1.4)));
      
      // Test if edge pixels at gray=80 would be detected
      const edgeGray = 80;
      const detectedOld = edgeGray <= oldThresh;
      const detectedNew = edgeGray <= newThresh;
      
      return `Sampled at gray=${sampledGray}:<br/>` +
             `OLD threshold=${oldThresh}, detects edge(${edgeGray})=${detectedOld}<br/>` +
             `NEW threshold=${newThresh}, detects edge(${edgeGray})=${detectedNew} ‚úÖ (more robust)`;
    });

    test('Aspect ratio filtering', () => {
      // Test that circular blobs pass aspect ratio filter
      const testCases = [
        { w: 20, h: 20, expected: true, desc: 'perfect circle' },
        { w: 20, h: 18, expected: true, desc: 'slightly oval' },
        { w: 20, h: 15, expected: true, desc: 'moderately oval' },
        { w: 20, h: 8, expected: false, desc: 'very elongated' },
      ];
      
      const aspectMin = 0.5;  // New value
      const aspectMax = 2.0;  // New value
      
      const results = testCases.map(tc => {
        const ar = tc.w / tc.h;
        const passes = (ar >= aspectMin && ar <= aspectMax);
        const match = passes === tc.expected;
        return `${match ? '‚úÖ' : '‚ùå'} ${tc.desc}: AR=${ar.toFixed(2)}, passes=${passes}`;
      });
      
      const allPass = testCases.every(tc => {
        const ar = tc.w / tc.h;
        const passes = (ar >= aspectMin && ar <= aspectMax);
        return passes === tc.expected;
      });
      
      assert(allPass, 'All test cases should match expected results');
      return results.join('<br/>');
    });

    test('Area filtering with new defaults', () => {
      const testCases = [
        { area: 40, expected: false, desc: 'too small' },
        { area: 50, expected: true, desc: 'minimum valid' },
        { area: 250, expected: true, desc: 'typical sticker' },
        { area: 8000, expected: true, desc: 'maximum valid' },
        { area: 9000, expected: false, desc: 'too large' },
      ];
      
      const minArea = 50;   // New value
      const maxArea = 8000; // New value
      
      const results = testCases.map(tc => {
        const passes = (tc.area >= minArea && tc.area <= maxArea);
        const match = passes === tc.expected;
        return `${match ? '‚úÖ' : '‚ùå'} ${tc.desc}: area=${tc.area}, passes=${passes}`;
      });
      
      const allPass = testCases.every(tc => {
        const passes = (tc.area >= minArea && tc.area <= maxArea);
        return passes === tc.expected;
      });
      
      assert(allPass, 'All test cases should match expected results');
      return results.join('<br/>');
    });

    test('Real-world scenario: Two pucks on wood', () => {
      // Simulate the uploaded image: wood board ~130 gray, black sticker ~70, white sticker ~180
      const canvas = createTestImage(200, 100, (x, y) => {
        // Blue puck (black sticker) at (50, 50)
        const d1 = Math.sqrt((x-50)**2 + (y-50)**2);
        if (d1 < 12) {
          return { r: 70, g: 70, b: 70 }; // Black sticker
        }
        
        // Red puck (white sticker) at (150, 50)
        const d2 = Math.sqrt((x-150)**2 + (y-50)**2);
        if (d2 < 12) {
          return { r: 180, g: 180, b: 180 }; // White sticker
        }
        
        // Wood background
        return { r: 140, g: 125, b: 105 };
      });
      
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, 200, 100);
      
      const blackMask = detectBlackPixels(imageData, 95);
      const whiteMask = detectWhitePixels(imageData, 165);
      
      const blackCount = countMaskPixels(blackMask);
      const whiteCount = countMaskPixels(whiteMask);
      
      const expectedArea = Math.PI * 12 * 12;
      
      assertApprox(blackCount, expectedArea, 50, 'Should detect blue puck black sticker');
      assertApprox(whiteCount, expectedArea, 50, 'Should detect red puck white sticker');
      
      resultsEl.appendChild(canvas);
      return `Blue puck: ${blackCount} pixels (expected ~${Math.round(expectedArea)})<br/>` +
             `Red puck: ${whiteCount} pixels (expected ~${Math.round(expectedArea)})`;
    });

    test('Edge case: Very dark lighting', () => {
      // Black sticker at gray=30, white sticker at gray=120, wood at gray=80
      const blackGray = 30;
      const whiteGray = 120;
      const woodGray = 80;
      
      // With sampling: black threshold = 30 * 1.4 = 42
      //                white threshold = 120 * 0.85 = 102
      const blackThresh = Math.round(blackGray * 1.4);
      const whiteThresh = Math.round(whiteGray * 0.85);
      
      const blackDetected = blackGray <= blackThresh;
      const whiteDetected = whiteGray >= whiteThresh;
      const woodBlackDetected = woodGray <= blackThresh;
      const woodWhiteDetected = woodGray >= whiteThresh;
      
      assert(blackDetected, 'Black sticker should be detected');
      assert(whiteDetected, 'White sticker should be detected');
      assert(!woodBlackDetected, 'Wood should not be detected as black');
      assert(!woodWhiteDetected, 'Wood should not be detected as white');
      
      return `Black sticker: ‚úÖ detected<br/>` +
             `White sticker: ‚úÖ detected<br/>` +
             `Wood background: ‚úÖ correctly excluded`;
    });

    // Run all tests and show summary
    window.addEventListener('load', () => {
      const passed = results.filter(r => r.pass).length;
      const failed = results.filter(r => !r.pass).length;
      const total = results.length;
      
      summaryEl.innerHTML = `
        <div style="color: ${failed === 0 ? '#36d399' : '#fb7185'}">
          ${failed === 0 ? '‚úÖ All tests passed!' : '‚ö†Ô∏è Some tests failed'}
        </div>
        <div style="font-size: 14px; margin-top: 10px; color: #9fb0c2;">
          Passed: ${passed} / ${total} | Failed: ${failed} / ${total}
        </div>
      `;
      
      if (failed > 0) {
        const failedTests = results.filter(r => !r.pass);
        summaryEl.innerHTML += `<div class="code"><pre>Failed tests:\n${failedTests.map(t => `- ${t.name}: ${t.error}`).join('\n')}</pre></div>`;
      }
    });
  </script>
</body>
</html>
